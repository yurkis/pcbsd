#!/bin/sh
# Script which performs updating services
############################################################################

# Source our functions
. /usr/local/share/pcbsd/scripts/functions.sh

# Set the program location
PROGDIR="/usr/local/share/pcbsd/pc-updatemanager" ; export PROGDIR

# Start by sourcing /etc/profile
# This grabs any HTTP_ / FTP_ PROXY variables
. /etc/profile

PCBSD_ETCCONF="/usr/local/etc/pcbsd.conf"
export PCBSD_ETCCONF

# Set the pub openssl key
SKEY="${PROGDIR}/conf/security.key" ; export SKEY

# Directory to store downloaded updates
DOWNLOADDIR="/usr/local/tmp"

# Get the system version we are checking for updates to
SYSVER="`uname -r | cut -d '-' -f 1-2`" ; export SYSVER

# Get the system type
SYSTYPE="`/usr/local/bin/pbreg get /PC-BSD/SysType`" ; export SYSTYPE

# Set the config location
UPDATECONF="${PROGDIR}/conf/sysupdate.conf"

# Set the system arch type
ARCH=`uname -m`

# Patchset Data
PATCHSERVER="`cat ${UPDATECONF} | grep '^UPDATESERVER:' | cut -d ' ' -f 2`"
PATCHSET="`cat ${UPDATECONF} | grep '^PATCHSET:' | cut -d ' ' -f 2`"
PATCHFILE="${PATCHSET}.upd"
PATCHURL="${PATCHSERVER}/${PATCHFILE}"
PATCHTMPDIR=`mktemp -d /tmp/.sysupdateXXXXXX`
PATCHTMPFILE="${PATCHTMPDIR}/sysupdate-${SYSVER}.upd"

MUSTAGEDIR="${DOWNLOADDIR}/update-stagedir"

# Enable ftp passive mode for file transfers
FTP_PASSIVE_MODE="YES" ; export FTP_PASSIVE_MODE

if [ ! -d "${DOWNLOADDIR}" ]; then mkdir -p ${DOWNLOADDIR}; fi

# Location for custom scripts for upgrades
UPDATEDOTD="/usr/local/etc/pcupdate.d"

# Trigger File for Tray Application
TRIGGERFILE="/tmp/.sysupdatetraytrigger"

DBDIR="/var/db/pc-updatemanager"
INSDIR="${DBDIR}/installed"
IGNDIR="${DBDIR}/ignored"

# PKG_CMD to use
PKG_CMD="/usr/sbin/pkg"

# Make sure we don't keep these from system environment
unset INJAIL PKG_FLAG

ISOTMP="/usr/local/tmp/pcbsd-update.iso"

# The default log file for output messages
LOGOUT="/var/log/pc-updatemanager.log"

# Return codes
PKGUPDATERTN=100
FBSDUPDATEONLYRTN=150
FBSDMAJORONLYRTN=151
FBSDUPDATEPLUSMAJORRTN=152
UPDATEOTHERRTN=125

######################################################################
# Done with config values
######################################################################

# Get the PACKAGE_SET to use for this pkgng repo
PACKAGE_SET="PRODUCTION"
_pkgChk="`sed -n 's/PACKAGE_SET: //p' ${PCBSD_ETCCONF} 2>/dev/null | awk '{print $1}'`"
if [ -n "${_pkgChk}" ] ; then PACKAGE_SET="$_pkgChk" ; fi

AUTO_UPDATE="securitypkg"
_upChk="`sed -n 's/AUTO_UPDATE: //p' ${PCBSD_ETCCONF} 2>/dev/null | awk '{print $1}'`"
if [ -n "${_upChk}" ] ; then AUTO_UPDATE="$_upChk" ; fi

CDN_TYPE="HTTP"
_cdnChk="`sed -n 's/CDN_TYPE: //p' ${PCBSD_ETCCONF} 2>/dev/null | awk '{print $1}'`"
if [ -n "${_cdnChk}" ] ; then CDN_TYPE="$_cdnChk" ; fi

# Check the PACKAGE_SET variable
case $PACKAGE_SET in
  ENTERPRISE|PRODUCTION|EDGE) ;;
  CUSTOM) # Using a custom package set?
          # Lets check that we have a URL provided
	  _urlChk="`sed -n 's/^PACKAGE_URL: //p' ${PCBSD_ETCCONF} 2>/dev/null | awk '{print $1}'`"
	  if [ -z "${_urlChk}" ] ; then
	     echo "Warning: PACKAGE_SET is CUSTOM, but no PACKAGE_URL set!"
	     echo "Reverting back to PRODUCTION repo..."
	     sleep 3
             CUSTOM_URL=""
	     PACKAGE_SET="PRODUCTION"
	  else
	     CUSTOM_URL="$_urlChk"
          fi
	  _urlChk="`sed -n 's/^CURSYS_PACKAGE_URL: //p' ${PCBSD_ETCCONF} 2>/dev/null | awk '{print $1}'`"
	  if [ -z "${_urlChk}" ] ; then
             CUSTOM_CURSYS_URL=""
	  else
	     CUSTOM_CURSYS_URL="$_urlChk"
          fi
          ;;
       *) echo "Warning: Invalid PACKAGE_SET!" 
          PACKAGE_SET="PRODUCTION" ;; 
esac

# Run-command, halt if command exits with non-0
rc_halt_cleanup()
{
  CMD="$@"

  if [ -z "${CMD}" ] ; then
    exit_err "Error: missing argument in rc_halt_cleanup()"
  fi
  echo "Running: $CMD" >> ${LOGOUT}

  ${CMD}
  STATUS=$?
  if [ ${STATUS} -ne 0 ] ; then
    sync ; sleep 2
    # Cleanup the boot-environment
    umount -f $STAGEMNT/dev 2>/dev/null >/dev/null
    umount -f $STAGEMNT 2>/dev/null >/dev/null
    beadm destroy -F $STAGEBE
    echo "Error ${STATUS}: ${CMD}" >> ${LOGOUT}
    exit_err "Error ${STATUS}: ${CMD}"
  fi
}

show_usage() {
        echo "pc-updatemanager: Usage
----
  branches 		- List available system branches
  chbranch <tag> 	- Change to new system branch
  check 		- Check for system updates
  showeol               - Show end of life (support) date for this release
  install <tag>,<tag2> 	- Install system updates
  pkgcheck 		- Check for updates to packages
  pkgupdate [-f]	- Install packages updates (-f to force)
  fbsdupdate		- Install freebsd-update patches
  fbsdupdatepkgs	- Install freebsd-update patches and any package updates
  syncconf		- Update PC-BSD pkgng configuration
  confcheck		- Check PC-BSD pkgng configuration
  cron                  - Perform delayed check for system and pkgng updates.
"	

	exit 1
}

echo_log()
{
   echo "$@"
   echo "$@" >> ${LOGOUT}
}

setup_pkgng_conf() {

  # See if we need to adjust pcbsd.conf repo file
  if [ ! -e "/usr/local/etc/pkg/repos/pcbsd.conf.dist" ];then
     echo "WARNING: Missing /usr/local/etc/pkg/repos/pcbsd.conf.dist"
     status="1"
     return 1
  fi

  # Remove old pkg conf
  if [ -e "/usr/local/etc/pkg/repos/pcbsd.conf" ] ; then
    rm /usr/local/etc/pkg/repos/pcbsd.conf
  fi

  ARCH=`uname -m`
  FBSDVER=`uname -r | cut -d '-' -f 1-2`
  MAJORVER="`uname -r | cut -d '-' -f 1 |  cut -d '.' -f 1`.0-RELEASE"

  # Make sure we are on a -RELEASE, otherwise use the proper uname
  echo $FBSDVER | grep -q -e 'RELEASE' -e 'STABLE'
  if [ $? -ne 0 ] ; then MAJORVER="$FBSDVER"; fi

  # If using the EDGE package set, set the right path
  case $PACKAGE_SET in
       EDGE) FBSDVER="$FBSDVER/edge"
	     MAJORVER="$MAJORVER/edge"
	     ;;
 ENTERPRISE) FBSDVER="$FBSDVER/enterprise"
	     MAJORVER="$MAJORVER/enterprise"
	     ;;
          *) ;;
  esac

  # Now create standard pcbsd.conf file
  if [ "$PACKAGE_SET" = "CUSTOM" -a -n "$CUSTOM_URL" ] ; then
     # Change %VERSION% / %ARCH% keys
     CUSTOM_URL=`echo $CUSTOM_URL | sed "s|%VERSION%|$MAJORVER|g" | sed "s|%ARCH%|$ARCH|g"`
     cat << EOF >/usr/local/etc/pkg/repos/pcbsd.conf
pcbsd-major: {
               url: "$CUSTOM_URL",
               signature_type: "fingerprints",
               fingerprints: "/usr/local/etc/pkg/fingerprints/pcbsd",
               enabled: true
              }
EOF
  else
     # Not using a CUSTOM repo
     if [ "$CDN_TYPE" = "IPFS" -a -e "/usr/local/etc/rc.d/ipfs-go" ] ; then
        # Get current IPFS CDN Hash for this release
	fetch -o /tmp/.ipfs-cdn.$$ "http://download.pcbsd.org/ipfs/$MAJORVER/$ARCH/hash-current" 2>/dev/null >/dev/null
	_err=$?
	PKGHASH=`cat /tmp/.ipfs-cdn.$$ 2>/dev/null`
        rm /tmp/.ipfs-cdn.$$ >/dev/null 2>/dev/null
	if [ $_err -ne 0 -o -z "$PKGHASH" ] ; then
	   echo "Falling back to HTTP mirror"
	   sed_pkg_repo_file_http
	   return 0
	fi

	# Save the new IPFS CDN pkg config
        cat << EOF >/usr/local/etc/pkg/repos/pcbsd.conf
pcbsd-major: {
               url: "http://127.0.0.1:8080/ipfs/${PKGHASH}",
               signature_type: "fingerprints",
               fingerprints: "/usr/local/etc/pkg/fingerprints/pcbsd",
               enabled: true
              }
EOF
     else
	sed_pkg_repo_file_http
     fi
  fi
}

sed_pkg_repo_file_http() {
  cat /usr/local/etc/pkg/repos/pcbsd.conf.dist \
	| sed "s|pcbsd: |pcbsd-major: |g" \
	| sed "s|%VERSION%|$MAJORVER|g" \
	| sed "s|%ARCH%|$ARCH|g" \
	| sed "s|VERSION|$MAJORVER|g" \
	| sed "s|ARCH|$ARCH|g" > /usr/local/etc/pkg/repos/pcbsd.conf
}

get_update_file() {

  # Now fetch the update file
  get_file "${PATCHURL}" "${PATCHTMPFILE}" 1 >/dev/null 2>/dev/null
  if [ $? -ne 0 ] ; then
     rm ${PATCHTMPFILE} 2>/dev/null
     is_net_up
     if [ $? -eq 0 ] ; then 
       echo "No updates available for $SYSVER!" ; exit 0 
     else
       exit_err "Could not contact update server!"
     fi
  fi

  # Now fetch the update file signature
  get_file "${PATCHURL}.sha1" "${PATCHTMPFILE}.sha1" 1 >/dev/null 2>/dev/null
  if [ $? -ne 0 ] ; then
     rm ${PATCHTMPFILE}.sha1 2>/dev/null
     is_net_up
     if [ $? -eq 0 ] ; then 
       echo "No updates available for $SYSVER!" ; exit 0 
     else
       echo_log "Could not contact update server!"
       exit_err "Could not contact update server!"
     fi
  fi

  # Lets verify the signature of the file
  openssl dgst -sha1 -verify ${SKEY} \
	-signature ${PATCHTMPFILE}.sha1 \
        ${PATCHTMPFILE} >/dev/null 2>/dev/null
  if [ $? -ne 0 ] ; then
     rm ${PATCHTMPFILE} 2>/dev/null
     rm ${PATCHTMPFILE}.sha1 2>/dev/null
     echo_log "Update file failed verification..."
     exit_err "Update file failed verification..."
  fi

  # Done with the signature we can discard
  rm ${PATCHTMPFILE}.sha1

}

do_branch() {
  up="$1"

  # Setup our variable to catch if we have a bad branch
  BRANCHFOUND="0" 

  while read line
  do
     echo $line | grep -q "^BRANCHES:"
     if [ $? -eq 0 ] ; then
	for i in `echo $line | cut -d ':' -f 2 | sed 's|,| |g'`
	do
  	  if [ "$i" != "$up" ] ; then continue ;fi
  	  if [ "`uname -r | cut -d '-' -f 1-2`" = "$up" ] ; then 
	     echo "You are already on this branch!"
             BRANCHFOUND="1"
	     continue;
	  fi
          update_world_and_pkgs "$up"
          BRANCHFOUND="1"
	  break
	done
     fi
  done < ${PATCHTMPFILE}

  # If no patches
  if [ "${BRANCHFOUND}" = "0" ]; then 
     # No available updates
     echo "Unknown branch ${1}"
  fi

  rm ${PATCHTMPFILE}

};

list_branches() {
  # Setup our variable, we have no branches so far
  BRANCHFOUND="0" 

  while read line
  do
     echo $line | grep -q "^BRANCHES:"
     if [ $? -eq 0 ] ; then
	echo "Available branches:"
	echo "* = Current Branch"
        echo "----------------------------------"
	echo $line | cut -d ':' -f 2 | sed 's|,|\
|g' | while read branch
	do
		if [ "`uname -r | cut -d '-' -f 1-2`" = "$branch" ] ; then
			echo "$branch *"
		else
			echo "$branch"
		fi
	done
	echo ""
	echo "To change branches run: ${0} chbranch <branch>"
        BRANCHFOUND="1"
        continue
     fi
  done < ${PATCHTMPFILE}

  # If no patches
  if [ "${BRANCHFOUND}" = "0" ]; then 
     # No available updates
     echo "No branches currently available!"
  fi

  rm ${PATCHTMPFILE}

};

do_fbsdcheck() {
  # Setup our variable, we have no patches so far
  PATCHFOUND="0" 
  echo "Checking for FreeBSD updates..."
  if [ "`id -u`" = "0" ] ; then
    pc-fbsdupdatecheck | grep -q "will be updated"
    if [ $? -eq 0 ] ; then
       PATCHFOUND="1"
    fi
  else
    sudo /usr/local/bin/pc-fbsdupdatecheck | grep -q "will be updated"
    if [ $? -eq 0 ] ; then
       PATCHFOUND="1"
    fi
  fi

  if [ "${PATCHFOUND}" = "1" ]; then
    echo "The following updates are available:"
    echo "------------------------------------"
    echo "NAME: FreeBSD security updates"
    echo "TYPE: SECURITYUPDATE"
    echo " "
    echo "To install: \"pc-updatemanager fbsdupdate\""
    echo " "

    if [ -e "/usr/local/bin/pc-systemflag" ]; then
      pc-systemflag SYSUPDATE UPDATE #set the system flag that system updates are available
    fi
    HAVEFREEBSDUPDATES="YES"
  fi
}

do_check() {

  while read line
  do
     echo $line | grep -q "^MAJOR:"
     if [ $? -eq 0 ] ; then
        parse_mu_update_line "$line"
        continue
     fi
     echo $line | grep -q "^SA:"
     if [ $? -eq 0 ] ; then
        parse_sa_update_line "$line"
        continue
     fi
     echo $line | grep -q "^EOL:"
     if [ $? -eq 0 ] ; then
        parse_eol_line "$line"
        continue
     fi
  done < ${PATCHTMPFILE}

  # If no patches
  if [ "${PATCHFOUND}" = "0" ]; then 
     # No available updates
     echo "Your system is up to date!"
     if [ -e "/usr/local/bin/pc-systemflag" ]; then
       pc-systemflag SYSUPDATE SUCCESS #set the system flag that system is up to date
     fi
     rm ${PATCHTMPFILE}
     return 0
  fi

  if [ -e "/usr/local/bin/pc-systemflag" ]; then
    pc-systemflag SYSUPDATE UPDATE #set the system flag that system updates are available
  fi
  rm ${PATCHTMPFILE}

  if [ -n "$HAVEFREEBSDUPDATES" -a -n "$HAVEMAJORUPDATES" ] ; then
     return $FBSDUPDATEPLUSMAJORRTN
  fi
  if [ -n "$HAVEFREEBSDUPDATES" ] ; then
     return $FBSDUPDATEONLYRTN
  fi
  if [ -n "$HAVEMAJORUPDATES" ] ; then
     return $FBSDMAJORONLYRTN
  fi

  # Other updates
  return $UPDATEOTHERRTN
};

do_eol_display()
{
while read line
  do     
     echo $line | grep -q "^EOL:"
     if [ $? -eq 0 ] ; then
        parse_eol_line "$line"
        continue
     fi
  done < ${PATCHTMPFILE}

}

parse_eol_line()
{
   local line="$1"

   # Grab the values
   local sysEOLVer=`echo $line | cut -d ':' -f 2`
   local sysUpEOL=`echo $line | cut -d ':' -f 3`
   local curEpoc=`date +%s`
   local EOLdays=$(expr  \( ${sysUpEOL} - ${curEpoc} \) / \( 60 \* 60 \* 24 \) )

   if [ "$SYSVER" != "$sysEOLVer" ] ; then return; fi

   echo ""
   if [ $sysUpEOL -lt $curEpoc ] ; then
     echo "*WARNING* End of Life *WARNING*"
     echo "-----------------------------------"
     echo "This version of PC-BSD / TrueOS has passed its EOL date of:"
     echo "`date -j -r $sysUpEOL`"
     echo "You are strongly encouraged to upgrade your system!"
     echo "-----------------------------------"
   else
     echo "End of Life Notice"
     echo "-----------------------------------"
     echo "This version of PC-BSD / TrueOS has an EOL date of:"
     echo "`date -j -r $sysUpEOL`"
     echo "End of support (in days): $EOLdays"
     echo "-----------------------------------"
     echo ""
   fi
}

parse_mu_update_line()
{
   local line="$1"

   # Check if this is a major update we can install
   local sysUpOVer=`echo $line | cut -d ':' -f 2`
   local sysUpNVer=`echo $line | cut -d ':' -f 3`

   # Is this an update for our version?
   if [ "$SYSVER" != "$sysUpOVer" ] ; then return; fi

   if [ $PATCHFOUND -eq 0 ] ; then
      echo ""
      echo "The following updates are available:"
      echo "------------------------------------"
   fi
   echo "NAME: System Update to ${sysUpNVer}" 
   echo "TYPE: SYSTEMUPDATE" 
   echo "TAG: fbsd-${sysUpNVer}"
   echo "VERSION: ${sysUpNVer}" 
   echo ""
   echo "To install: \"pc-updatemanager install fbsd-${sysUpNVer}\""
   echo ""
   echo ""

   PATCHFOUND="`expr ${PATCHFOUND} + 1`" 
   HAVEMAJORUPDATE="YES"
}

parse_sa_update_line()
{
   local line="$1"

   # Check if this is an update we can install
   local saVer=`echo $line | cut -d ':' -f 2`
   local saArch=`echo $line | cut -d ':' -f 3`
   local saType=`echo $line | cut -d ':' -f 4`
   local saIdent="`echo $line | cut -d ':' -f 5`"

   # For this version?
   if [ "$SYSVER" != "$saVer" ] ; then return ; fi

   # For this system arch?
   if [ "$ARCH" != "$saArch" -a "$saArch" != "noarch" ] ; then return ; fi

   # For this system type?
   if [ "$SYSTYPE" != "$saType" -a "$saType" != "both" ] ; then return ; fi

   # Already installed?
   if [ -e "${INSDIR}/${SYSVER}/$saIdent" ] ; then return ; fi

   if [ $PATCHFOUND -eq 0 ] ; then
      echo ""
      echo "The following updates are available:"
      echo "------------------------------------"
   fi
   local saDesc="`echo $line | cut -d ':' -f 6`"
   local saSize=`echo $line | cut -d ':' -f 8`
   local saDetail="http://wiki.pcbsd.org`echo $line | cut -d ':' -f 10`"
   local saDate="`echo $line | cut -d ':' -f 11`"

   echo "NAME: ${saDesc}" 
   echo "TYPE: PATCH" 
   echo "TAG: ${saIdent}"
   echo "DETAILS: ${saDetail}"
   echo "DATE: ${saDate}"
   echo "SIZE: ${saSize}Mb" 
   echo " "
   echo "To install: \"pc-updatemanager install ${saIdent}\""
   echo " "

   PATCHFOUND="`expr ${PATCHFOUND} + 1`" 
}

start_pcbsd_patch() {
  local up="$1"
  local saIdent=""
  local saVer=""
  local saArch=""
  local saPlat=""
  local saUrl=""
  local saDesc=""
  local saCsum=""
  local patchLine=""
  if [ -e "${INSDIR}/${SYSVER}/${up}" ]; then 
     rm ${PATCHTMPFILE}
     exit_err "Patch $up already installed!"
  fi

  while read line
  do
    echo $line | grep -q "^SA:"
    if [ $? -ne 0 ] ; then continue; fi
    saIdent="`echo $line | cut -d ':' -f 5`"
    # Look for the right stand-alone update
    if [ "$saIdent" != "$up" ] ; then continue ; fi
    saVer=`echo $line | cut -d ':' -f 2`
    saArch=`echo $line | cut -d ':' -f 3`
    saType=`echo $line | cut -d ':' -f 4`
    # Does this update apply to this system arch?
    if [ "$saArch" != "$ARCH" -a "$saArch" != "noarch" ] ; then 
       rm ${PATCHTMPFILE}
       exit_err "Patch $up is not for this system arch type!"
    fi
    # For this version?
    if [ "$saVer" != "$SYSVER" ] ; then 
       rm ${PATCHTMPFILE}
       exit_err "Patch $up is not for this system version!"
    fi

    # For this system type?
    if [ "$SYSTYPE" != "$saType" -a "$saType" != "both" ] ; then
       rm ${PATCHTMPFILE}
       exit_err "Patch $up is not for this system type!"
    fi

    # Got here? We have a patch ready to go
    patchLine="$line"
    break
  done < ${PATCHTMPFILE}

  # Did we find the patch?
  if [ -z "$patchLine" ] ; then 
     rm ${PATCHTMPFILE}
     exit_err "Patch $up not found!"
  fi

  # Get the patch details
  saVer=`echo $patchLine | cut -d ':' -f 2`
  saArch=`echo $patchLine | cut -d ':' -f 3`
  saPlat=`echo $patchLine | cut -d ':' -f 4`
  saIdent="`echo $patchLine | cut -d ':' -f 5`"
  saDesc="`echo $patchLine | cut -d ':' -f 6`"
  saUrl="`echo $patchLine | cut -d ':' -f 7`"
  saCsum="`echo $patchLine | cut -d ':' -f 9`"
  local FILENAME="`basename $saUrl`"

  # Start downloading the patch
  touch ${TRIGGERFILE}
  echo "DOWNLOADING: ${saIdent}"
  echo "DOWNLOADING: ${saIdent}" >${TRIGGERFILE}

  # Get the file
  get_file_from_mirrors "/${saUrl}" "${DOWNLOADDIR}/${FILENAME}" "update"
  if [ $? -ne 0 ] ; then
     rm ${PATCHTMPFILE}
     echo "FAILED: ${saIdent}" >${TRIGGERFILE}
     exit_err "Failed to download: ${saIdent}"
  fi

  # Check the sha256 checksum
  if [ "$saCsum" != "`sha256 -q ${DOWNLOADDIR}/${FILENAME} 2>/dev/null`" ]
  then
     # Download MD5 doesn't match! Delete the file
     rm ${PATCHTMPFILE}
     rm ${DOWNLOADDIR}/${FILENAME}
     echo "FAILED: ${saIdent}" >${TRIGGERFILE}
     exit_err "Failed to download: ${saIdent}"
  else 
     echo "DOWNLOADFINISHED: ${saIdent}"
     echo "DOWNLOADFINISHED: ${saIdent}" >${TRIGGERFILE}
  fi

  echo "INSTALLING: ${saIdent}" >${TRIGGERFILE}
  sleep 1

  # Lets auto-create a new boot-environment before updating
  create_auto_beadm

  PATCHTMPDIR="`mktemp -d ${DOWNLOADDIR}/patchInstallXXXXX`"
  rc_halt "tar xvJf ${DOWNLOADDIR}/${FILENAME} -C ${PATCHTMPDIR}" 2>/dev/null
  PATCHDIR="$PATCHTMPDIR" ; export PATCHDIR
  cd ${PATCHTMPDIR}
  sh update.sh
  if [ $? -eq 0 ]; then
     touch "${INSDIR}/${SYSVER}/${saIdent}"
     echo "INSTALLFINISHED: ${saIdent}"
     echo "INSTALLFINISHED: ${saIdent}" >${TRIGGERFILE}
  else
     rm ${PATCHTMPFILE}
     rm -rf ${PATCHTMPDIR}
     rm ${DOWNLOADDIR}/${FILENAME}
     echo "INSTALLFAILED: ${saIdent}" >${TRIGGERFILE}
     exit_err "INSTALLFAILED: ${saIdent}"
  fi

  rc_halt "rm -rf ${PATCHTMPDIR}"
  rc_halt "rm ${DOWNLOADDIR}/${FILENAME}"
}

do_install() {
	if [ -z "$1" ] ; then exit_err "No updates specified to install!"; fi

	if [ -e "/usr/local/bin/pc-systemflag" ]; then
	  pc-systemflag SYSUPDATE UPDATING #set the flag that system is updating
	fi
	# Begin to update the selected items
	for up in `echo $1 | sed 's|,| |g'`
	do
	  # If this is a major update, start it up!
  	  echo $up | grep -q "^fbsd-" 
	  if [ $? -eq 0 ] ; then 
            update_world_and_pkgs "`echo $up | sed 's|fbsd-||g'`"
	    exit 0
          else
	    # Doing regular pcbsd patch
	    start_pcbsd_patch "${up}"
            continue
          fi
	done 
	if [ -e "/usr/local/bin/pc-systemflag" ]; then
	  pc-systemflag SYSUPDATE SUCCESS #set the flag that system updates finished
	fi
        # All Finished!
        rm ${PATCHTMPFILE}
        exit 0
}

is_net_up() {
	ping -c 1 www.pcbsd.org >/dev/null 2>/dev/null
	ret=$?
	if [ $ret -ne 0 ]; then
	  if [ -e "/usr/local/bin/pc-systemflag" ]; then
	    pc-systemflag NETRESTART ERROR #set the system flag that no internet available
	  fi
	fi
	return $ret
}

sync_pkgconf() {
  # Update systems pkgng configuration
  setup_pkgng_conf
}

check_pkgconf() {

  # Update systems pkgng configuration
  setup_pkgng_conf
  exit $?
}

checkup_pkgs() {

  # Update the repo DB
  if [ "`id -u`" = "0" ] ; then
    rc_halt "${PKG_CMD} update"
  fi

  ${PKG_CMD} ${PKG_FLAG} upgrade -n >/tmp/.pkgData.$$
  if [ $? -ne 0 ] ; then
     echo "Error checking for package updates..."
     if [ -e "/usr/local/bin/pc-systemflag" ]; then
       pc-systemflag PKGUPDATE ERROR #set the system flag pkg check errored
     fi
     exit 1
  fi

  # Check for updates now
  grep -q "Your packages are up to date" /tmp/.pkgData.$$
  if [ $? -eq 0 ] ; then
     echo "All packages are up to date!"
     if [ -e "/usr/local/bin/pc-systemflag" ]; then
       pc-systemflag PKGUPDATE SUCCESS #set the system flag that packages are up to date
     fi
     rm /tmp/.pkgData.$$
     return 0
  fi

  # Display the pkg update data
  cat /tmp/.pkgData.$$
  rm /tmp/.pkgData.$$
  echo "The following updates are available:"
  echo "------------------------------------"
  echo "NAME: System package updates"
  echo "TYPE: PKGUPDATE"
  echo " "
  echo "To install: \"pc-updatemanager pkgupdate\""
  if [ -e "/usr/local/bin/pc-systemflag" ]; then
    pc-systemflag PKGUPDATE UPDATE #set the system flag that updates available
  fi
  return $PKGUPDATERTN
}

set_update_vars()
{
  unset EVENT_PIPE

  # Set some locations
  STAGEBE="updaterstage"
  STAGEMNT="/.updateStage"
  OLDPKGLIST="/tmp/.pkgUpdateList.$$"
  NEWPKGLIST="/tmp/.newPkgUpdateList.$$"
  PKGUPGRADELOG="/tmp/.pkgUpdateLog.$$"
  PKGDLCACHE="/usr/local/pkg-cache"
  touch ${PKGUPGRADELOG}

}

# Check that beadm exists before doing an update
check_valid_uptarget()
{
  /usr/bin/which -s beadm
  if [ $? -ne 0 ] ; then
     exit_err "No beadm installed! Is this a jail or non PC-BSD / TrueOS box?"
  fi
}

update_freebsd()
{
  check_valid_uptarget
  touch_updateinprogress

  pc-fbsdupdatecheck | grep -q "will be updated"
  if [ $? -ne 0 ] ; then
    exit_err "No FreeBSD updates available!"
  fi

  if [ -e "/usr/local/bin/pc-systemflag" ]; then
    pc-systemflag PKGUPDATE UPDATING #set the system flag that packages are updating
  fi

  # Check if user requested to do updates + pkgs
  doPkgUpdates="NO"
  if [ "$1" = "pkgs" ] ; then
    doPkgUpdates="YES"
  fi

  # First lets see if we have packages to update at the same time
  ${PKG_CMD} ${PKG_FLAG} upgrade -n >/tmp/.pkgData.$$
  grep -q "Your packages are up to date" /tmp/.pkgData.$$
  if [ $? -eq 0 ] ; then doPkgUpdates="NO"; fi
  rm /tmp/.pkgData.$$

  set_update_vars

  if [ "$doPkgUpdates" = "YES" ] ; then
    mk_pkg_conf
    build_pkg_list
    dl_pkgs
    run_update_pre "PKG"
  else
    run_update_pre "SECURITY"
  fi

  mk_stage_be
  mount_stage_be

  run_freebsd_update_script

  if [ "$doPkgUpdates" = "YES" ] ; then
    prep_pkgs_chroot
    install_pkgs_chroot
  fi

  umount_stage_be
  mk_stage_be_default

  if [ -e "/usr/local/bin/pc-systemflag" ]; then
    pc-systemflag PKGUPDATE SUCCESS #set the system flag that packages are up to date
  fi

  if [ "$doPkgUpdates" = "YES" ] ; then
    run_update_post "PKG"
  else
    run_update_post "SECURITY"
  fi

  touch_reboot
  echo_log "Your update is finished! Please reboot to load into the new boot-environment"
  exit 0
}

update_pkgs_only()
{
  check_valid_uptarget

  FULLUPDATE="NO"
  if [ "$1" = "-f" ] ; then
    FULLUPDATE="YES"
  fi

  # Make sure there are really packages to update
  if [ "$FULLUPDATE" != "YES" ] ; then
    checkup_pkgs >/dev/null 2>/dev/null
    if [ $? -eq 0 ] ; then
       echo "Your packages are already up to date!"
       exit 0
    fi
  fi

  touch_updateinprogress
  doPkgUpdates="YES"

  if [ -e "/usr/local/bin/pc-systemflag" ]; then
    pc-systemflag PKGUPDATE UPDATING #set the system flag that packages are updating
  fi

  set_update_vars

  run_update_pre "PKG"
  mk_pkg_conf
  build_pkg_list
  dl_pkgs
  mk_stage_be
  mount_stage_be
  if [ "$FULLUPDATE" = "YES" ] ; then
    # We are doing a forced / full update, lets nuke and re-install all
    prep_pkgs_chroot
    install_pkgs_chroot
  else
    # Lets attempt a traditional PKG upgrade, fallback to full if that fails
    do_lite_pkgupdate_chroot
    if [ $? -ne 0 ] ; then
      echo_log "Failed incremental pkg upgrade! Doing full package upgrade now."
      prep_pkgs_chroot
      install_pkgs_chroot
    fi
  fi
  umount_stage_be
  mk_stage_be_default

  if [ -e "/usr/local/bin/pc-systemflag" ]; then
    pc-systemflag PKGUPDATE SUCCESS #set the system flag that packages are up to date
  fi

  run_update_post "PKG"

  touch_reboot
  echo_log "Your update is finished! Please reboot to load into the new boot-environment"
  exit 0
}

update_world_and_pkgs()
{
  check_valid_uptarget

  # Set the new version of FreeBSD we are installing
  NEWFREEBSDVERSION="$1"
  doPkgUpdates="YES"

  touch_updateinprogress

  if [ -e "/usr/local/bin/pc-systemflag" ]; then
    pc-systemflag PKGUPDATE UPDATING #set the system flag that packages are updating
  fi

  set_update_vars

  run_update_pre "SYSTEM"
  mk_pkg_conf
  build_pkg_list
  dl_pkgs
  mk_stage_be
  mount_stage_be
  prep_pkgs_chroot
  prep_rc_script
  umount_stage_be
  mk_stage_be_default

  if [ -e "/usr/local/bin/pc-systemflag" ]; then
    pc-systemflag PKGUPDATE SUCCESS #set the system flag that packages are up to date
  fi

  run_update_post "SYSTEM"

  touch_reboot
  echo_log "Update stage one is finished! Please reboot to start stage 2."

  exit 0
}

mk_pkg_conf()
{
   PKG_FLAG=""
   PKG_CFLAG=""

   if [ ! -d "$PKGDLCACHE" ] ; then
     mkdir -p $PKGDLCACHE
   fi

   # Get rid of FreeBSD.conf repo
   if [ -e "/etc/pkg/FreeBSD.conf" ] ; then
      rm /etc/pkg/FreeBSD.conf
   fi

   # Set the cache directory
   PKG_CFLAG="-C /tmp/.pkgUpdate.conf"
   echo "PKG_CACHEDIR: $PKGDLCACHE" > /tmp/.pkgUpdate.conf

   # If doing a major update also, add the new repos config
   if [ -n "$NEWFREEBSDVERSION" ] ; then
      setup_pkgng_newrepo_conf
   fi
}

setup_pkgng_newrepo_conf() {

  # Lets create a new repo file to match the version of BSD we are upgrading to

  # Set the new ABI
  ABIVER="`echo $NEWFREEBSDVERSION | cut -d '-' -f 1 | cut -d '.' -f 1`"
  #PKG_FLAG="$PKG_FLAG -o ABI=freebsd:$ABIVER:`uname -m`"
  PKG_FLAG="$PKG_FLAG -o ABI=freebsd:$ABIVER:x86:64"
  #echo "Setting ABI with: ${PKG_FLAG}"

  # See if we need to adjust pcbsd.conf repo file
  if [ ! -e "/usr/local/etc/pkg/repos/pcbsd.conf.dist" ];then
     echo_log "ERROR: Missing /usr/local/etc/pkg/repos/pcbsd.conf.dist"
     exit 1
  fi

  ARCH=`uname -m`
  FBSDVER="$NEWFREEBSDVERSION"
  MAJORVER="`echo $FBSDVER | cut -d '-' -f 1 |  cut -d '.' -f 1`.0-RELEASE"

  # Make sure we are on a -RELEASE or -STABLE, otherwise use the proper uname
  echo $FBSDVER | grep -q -e 'RELEASE' -e 'STABLE'
  if [ $? -ne 0 ] ; then MAJORVER="$FBSDVER"; fi

  # If using the EDGE package set, set the right path
  case $PACKAGE_SET in
       EDGE) FBSDVER="$FBSDVER/edge"
	     MAJORVER="$MAJORVER/edge"
	     ;;
          *) ;;
  esac

  rm -rf /usr/local/tmp/.updateRepo >/dev/null 2>/dev/null
  mkdir -p /usr/local/tmp/.updateRepo

  # Now create standard pcbsd.conf file
  if [ "$PACKAGE_SET" = "CUSTOM" -a -n "$CUSTOM_URL" ] ; then
     # Change %VERSION% / %ARCH% keys
     CUSTOM_URL=`echo $CUSTOM_URL | sed "s|%VERSION%|$MAJORVER|g" | sed "s|%ARCH%|$ARCH|g"`
     cat << EOF >/usr/local/tmp/.updateRepo/pkgUpdateRepo.conf
pcbsd-major: {
               url: "$CUSTOM_URL",
               signature_type: "fingerprints",
               fingerprints: "/usr/local/etc/pkg/fingerprints/pcbsd",
               enabled: true
              }
EOF
  else
    # Using PC-BSD CDN
    cat /usr/local/etc/pkg/repos/pcbsd.conf.dist \
      | sed "s|pcbsd: |pcbsd-major: |g" \
      | sed "s|%VERSION%|$MAJORVER|g" \
      | sed "s|%ARCH%|$ARCH|g" \
      | sed "s|VERSION|$MAJORVER|g" \
      | sed "s|ARCH|$ARCH|g" > /usr/local/tmp/.updateRepo/pkgUpdateRepo.conf
  fi

  # Set the new PKG_FLAG to use this repo config
  PKG_FLAG="-R /usr/local/tmp/.updateRepo ${PKG_FLAG}"
}

build_pkg_list()
{
  # Check if any packages are locked and bail if so
  pkg lock --has-locked-packages >/dev/null 2>/dev/null
  if [ $? -eq 0 ] ; then
    if [ -e "/usr/local/bin/pc-systemflag" ] ; then
      pc-systemflag PKGUPDATE ERROR
    fi
    exit_err "You have LOCKED packages in your repo! These must be unlocked, or you can run pkg upgrade manually."
  fi

  # Figure out which base to install
  pkg info -e pcbsd-base
  if [ $? -eq 0 -o -e "/etc/defaults/pcbsd" ] ; then
     SYSBASE="misc/pcbsd-base"
  else
     SYSBASE="misc/trueos-base"
  fi
  SYSBASEORIGIN="$SYSBASE"
  SYSBASEFILENAME="`${PKG_CMD} ${PKG_FLAG} rquery '%n-%v' $SYSBASE 2>/dev/null | head -n 1`.txz"

  # Build top-level list of pkgs installed
  ${PKG_CMD} query -e '%#r=0' '%o %n-%v' | sort | grep -v 'ports-mgmt/pkg ' | grep -v 'misc/pcbsd-base ' | grep -v 'misc/trueos-base ' > $OLDPKGLIST

  # If GRUB is used for boot, require it to be installed
  if [ -e "/boot/grub/grub.cfg" ]; then
     echo "sysutils/grub2-pcbsd grub2-pcbsd" >> $OLDPKGLIST
     echo "sysutils/grub2-efi grub2-efi" >> $OLDPKGLIST
  fi

  echo "Original top-level packages:" > $PKGUPGRADELOG
  echo "-----------------------------------------------" >> $PKGUPGRADELOG
  cat $OLDPKGLIST >> $PKGUPGRADELOG
  echo "-----------------------------------------------" >> $PKGUPGRADELOG
}

dl_pkgs()
{
  # Make sure PKG itself is upgraded
  echo_log "Checking for updates to ports-mgmt/pkg.."
  ${PKG_CMD} upgrade -y ports-mgmt/pkg

  # Update the DB first
  echo_log "Updating the package repo database..."
  ${PKG_CMD} ${PKG_FLAG} update -f >/dev/null 2>/dev/null
  sync
  sleep 2

  # Clean pkgs
  echo_log "Cleaning old pkg upgrade cache..."
  ${PKG_CMD} ${PKG_CFLAG} ${PKG_FLAG} clean -y >/dev/null 2>/dev/null
  sync
  sleep 2

  if [ -e "$NEWPKGLIST" ] ; then rm $NEWPKGLIST; fi
  touch ${NEWPKGLIST}

  # Save the PKGNG filename
  PKGFILENAME="`${PKG_CMD} ${PKG_FLAG} rquery -U '%n-%v' ports-mgmt/pkg 2>/dev/null | head -n 1`.txz"

  # First off, fetch the pkgng pkg
  echo_log "Verifying / fetching packages for ports-mgmt/pkg - $PKGFILENAME"
  echo "Verifying / fetching packages for ports-mgmt/pkg - $PKGFILENAME" >> ${PKGUPGRADELOG}
  ${PKG_CMD} ${PKG_CFLAG} ${PKG_FLAG} fetch -U -d -y ports-mgmt/pkg 2>&1 | tee -a ${PKGUPGRADELOG}
  if [ $? -ne 0 ] ; then
     if [ -e "/usr/local/bin/pc-systemflag" ] ; then
       pc-systemflag PKGUPDATE ERROR
     fi
     echo_log "Failed fetching: ports-mgmt/pkg - $PKGFILENAME" >> ${PKGUPGRADELOG}
     exit_err "Failed fetching: ports-mgmt/pkg - $PKGFILENAME"
  fi

  REALPKGDLCACHE="${PKGDLCACHE}"
  # PKGNG lies, we need to verify if the package was really downloaded
  if [ ! -e "${PKGDLCACHE}/${PKGFILENAME}" ] ; then
     # Also check All/ since pkg docs are rather unclear about if that will be used or not
     if [ -e "${PKGDLCACHE}/All/${PKGFILENAME}" ] ; then
        REALPKGDLCACHE="${PKGDLCACHE}/All"
     else
        if [ -e "/usr/local/bin/pc-systemflag" ] ; then
          pc-systemflag PKGUPDATE ERROR
        fi
	echo_log "Failed downloading ports-mgmt/pkg with: $PKG_CMD $PKG_FLAG fetch -d -y ports-mgmt/pkg" >> ${PKGUPGRADELOG}
        exit_err "Failed downloading ports-mgmt/pkg with: $PKG_CMD $PKG_FLAG fetch -d -y ports-mgmt/pkg"
     fi
  fi



  # Fetch the SYSBASE packages, halt if this fails
  SYSBASEFILENAME="`${PKG_CMD} ${PKG_FLAG} rquery -U '%n-%v' $SYSBASE 2>/dev/null | head -n 1`.txz"
  echo_log "Verifying / fetching packages for ${SYSBASE} - $SYSBASEFILENAME"
  echo "Verifying / fetching packages for ${SYSBASE} - $SYSBASEFILENAME" >> ${PKGUPGRADELOG}
  ${PKG_CMD} ${PKG_CFLAG} ${PKG_FLAG} fetch -U -d -y ${SYSBASE} 2>&1 | tee  -a ${PKGUPGRADELOG}
  if [ $? -ne 0 ] ; then
     if [ -e "/usr/local/bin/pc-systemflag" ] ; then
       pc-systemflag PKGUPDATE ERROR
     fi
     echo_log "Failed fetching: $SYSBASE - $SYSBASEFILENAME"
     echo "Failed fetching: $SYSBASE - $SYSBASEFILENAME" >> ${PKGUPGRADELOG}
     exit_err "Failed fetching: $SYSBASE - $SYSBASEFILENAME"
  fi

  # PKGNG lies, we need to verify if the package was really downloaded
  if [ ! -e "${REALPKGDLCACHE}/${SYSBASEFILENAME}" ] ; then
     if [ -e "/usr/local/bin/pc-systemflag" ] ; then
       pc-systemflag PKGUPDATE ERROR
     fi
     echo_log "Failed downloading $SYSBASE with: $PKG_CMD $PKG_FLAG fetch -d -y $SYSBASE"
     echo "Failed downloading $SYSBASE with: $PKG_CMD $PKG_FLAG fetch -d -y $SYSBASE" >> ${PKGUPGRADELOG}
     exit_err "Failed downloading $SYSBASE with: $PKG_CMD $PKG_FLAG fetch -d -y $SYSBASE"
  fi



  # Now start fetching all the update packages
  while read pkgLine
  do
    pkgOrigin="`echo $pkgLine | cut -d ' ' -f 1`"
    pkgName="`echo $pkgLine | cut -d ' ' -f 2`"

    # Check if this pkg exists in the new repo
    unset FETCHFILENAME
    FETCHFILENAME="`${PKG_CMD} ${PKG_FLAG} rquery -U '%n-%v' $pkgOrigin 2>/dev/null | head -n 1`"
    if [ -z "$FETCHFILENAME" ] ; then
       echo_log "*****"
       echo_log "No such package in new repo: $pkgOrigin"
       echo "*****" >> $PKGUPGRADELOG
       echo "No such package in new repo: $pkgOrigin" >> $PKGUPGRADELOG
       echo "*****" >> $LOGOUT
       echo "*****" >> $PKGUPGRADELOG
       continue
    fi
    FETCHFILENAME="${FETCHFILENAME}.txz"

    # Fetch the pkg now
    echo_log "Verifying / fetching packages for ${pkgOrigin} - $FETCHFILENAME"
    echo "Verifying / fetching packages for ${pkgOrigin} - $FETCHFILENAME" >> ${PKGUPGRADELOG}
    ${PKG_CMD} ${PKG_CFLAG} ${PKG_FLAG} fetch -U -d -y $pkgOrigin 2>&1 | tee -a ${PKGUPGRADELOG}
    # PKGNG lies, we need to verify if the package was really downloaded as well
    if [ $? -ne 0 ] || [ ! -e "${REALPKGDLCACHE}/${FETCHFILENAME}" ] ; then
      #Try one more time
      sleep 2
      echo_log " - Failure: Trying again"
      echo " - Failure: Trying again" >> ${PKGUPGRADELOG}
      ${PKG_CMD} ${PKG_CFLAG} ${PKG_FLAG} fetch -U -d -y $pkgOrigin 2>&1 | tee -a ${PKGUPGRADELOG}
       #Check again for success
       if [ $? -ne 0 ] || [ ! -e "${REALPKGDLCACHE}/${FETCHFILENAME}" ] ; then
         echo_log " - Failed again: Try again later"
	 echo " - Failed again: Try again later" >> ${PKGUPGRADELOG}
         echo_log "*****" ${PKGUPGRADELOG}
         echo_log "Failed fetching: $pkgOrigin" >> ${PKGUPGRADELOG}
         exit_err "Failed fetching: $pkgOrigin"
       fi
    fi

    # PKGNG lies, we need to verify if the package was really downloaded
    #if [ ! -e "${REALPKGDLCACHE}/${FETCHFILENAME}" ] ; then
       #echo_log "*****" ${PKGUPGRADELOG}
       #cat /tmp/.pkgOut.$$ >> ${LOGOUT}
       #echo_log "*****" >> ${PKGUPGRADELOG}
       #rm /tmp/.pkgOut.$$
       #echo_log "Failed fetching: $pkgOrigin"
       #exit_err "Failed fetching: $pkgOrigin"
    #fi
    echo "$pkgOrigin $FETCHFILENAME" >> $NEWPKGLIST
  done < $OLDPKGLIST

  echo_log "-----------------------------------------------"
  echo "-----------------------------------------------" >> ${PKGUPGRADELOG}
}

check_low_space()
{
  if [ -z "${REALPKGDLCACHE}" ] ; then return; fi
  if [ ! -d "${REALPKGDLCACHE}" ] ; then return; fi

  local poolFree=$(get_root_pool_free_space)
  if [ -z "$poolFree" ] ; then return ; fi

  cd ${REALPKGDLCACHE}
  local pkgCacheSpace=`du -kc *.txz | tail -1 | awk '{print $1}'`
  if [ ! $(is_num "$pkgCacheSpace") ] ; then return ; fi

  # We try to over-estimate space required for decompression, since we don't want ZFS to get
  # too full, it gets cranky at over 75%
  pkgCacheSpace=`expr $pkgCacheSpace \* 7`

  if [ $poolFree -lt $pkgCacheSpace ] ; then
     do_prune_be "force"
     poolFree=$(get_root_pool_free_space)
     if [ $poolFree -lt $pkgCacheSpace ] ; then
        SPACE=`expr $pkgCacheSpace / 1024`
        exit_err "Low disk-space - update halted! Please free at least ${SPACE}MB before running again."
     fi
  fi
}

mk_stage_be()
{
  echo_log "Creating stage BE..."
  umount -f $STAGEMNT/dev 2>/dev/null >/dev/null
  umount -f $STAGEMNT 2>/dev/null >/dev/null

  # Auto-prune any old / stale BEs
  do_prune_be

  # Do the low-space check
  check_low_space

  # Check for an existing BE for upgrades
  beadm list -H | awk '{print $1}' | grep -q "$STAGEBE"
  if [ $? -eq 0 ] ; then
     beadm destroy -F $STAGEBE
  fi

  # Create the new stage boot environment
  TMPNICK=`date "+%Y%m%d_%H%M%S"`
  rc_halt "beadm create $STAGEBE ${TMPNICK}" >>${LOGOUT} 2>>${LOGOUT}
}

mount_stage_be()
{
  # Get the stage mount-point ready
  echo_log "Mounting the stage BE..."
  if [ ! -d "$STAGEMNT" ] ; then mkdir -p $STAGEMNT; fi
  umount -f $STAGEMNT/dev 2>/dev/null >/dev/null
  umount -f $STAGEMNT 2>/dev/null >/dev/null

  # Mount the BE
  rc_halt "beadm mount $STAGEBE $STAGEMNT"
  if [ "$doPkgUpdates" = "YES" ] ; then
    rc_halt_cleanup "cp $NEWPKGLIST ${STAGEMNT}/install-pkg-list"
  fi
  rc_halt_cleanup "mount -t devfs devfs ${STAGEMNT}/dev"

  # Cleanup the old freebsd-update dir
  rm -rf ${STAGEMNT}/var/db/freebsd-update 2>/dev/null
  mkdir -p ${STAGEMNT}/var/db/freebsd-update 2>/dev/null
  chmod 600 ${STAGEMNT}/var/db/freebsd-update
}

do_lite_pkgupdate_chroot()
{
  # Need to export this before cleaning pkgs, some scripts may try to be interactive
  PACKAGE_BUILDING="YES"
  export PACKAGE_BUILDING

  echo_log "Starting pkg upgrade..."
  rc_halt_cleanup "chroot ${STAGEMNT} pkg unlock -ay" 2>&1 | tee -a ${LOGOUT}

  echo_log "Running: pkg upgrade -U -y"
  chroot ${STAGEMNT} pkg ${PKG_CFLAG} ${PKG_FLAG} upgrade -U -y 2>&1 | tee -a ${LOGOUT}
  return $?
}

prep_pkgs_chroot()
{
  # Now start our chroot commands

  # Need to export this before cleaning pkgs, some scripts may try to be interactive
  PACKAGE_BUILDING="YES"
  export PACKAGE_BUILDING

  # First, clean the BE old pkgs
  echo_log "Preparing the new boot-environment... (This may take a while)"
  rc_halt_cleanup "chroot ${STAGEMNT} pkg unlock -ay" 2>&1 | tee -a ${LOGOUT}
  rc_halt_cleanup "chroot ${STAGEMNT} pkg delete -ay" 2>&1 | tee -a ${LOGOUT}

  # Next create the script to bootstrap pkgng
  echo "#!/bin/sh
tar xvpf ${REALPKGDLCACHE}/${PKGFILENAME} -C / /usr/local/sbin/pkg-static >/dev/null 2>/dev/null

# Set the cache directory
PKG_CFLAG=\"-C /tmp/.pkgUpdate.conf\"
echo \"PKG_CACHEDIR: $PKGDLCACHE\" > /tmp/.pkgUpdate.conf

/usr/local/sbin/pkg-static \${PKG_CFLAG} ${PKG_FLAG} install -U -y -f ports-mgmt/pkg
if [ \$? -ne 0 ] ; then
  # If we fail to install pkgng, try updating first
  /usr/local/sbin/pkg-static \${PKG_CFLAG} update
  /usr/local/sbin/pkg-static \${PKG_CFLAG} ${PKG_FLAG} install -U -y -f ports-mgmt/pkg
  if [ \$? -ne 0 ] ; then
    echo "FAILED INSTALLING ports-mgmt/pkg"
    exit 1
  fi
fi
cd ${REALPKGDLCACHE}

# Need to export this before installing pkgs, some scripts may try to be interactive
PACKAGE_BUILDING=\"YES\"
export PACKAGE_BUILDING

# Cleanup the old /compat/linux for left-overs
umount /compat/linux/proc >/dev/null 2>/dev/null
umount /compat/linux/sys >/dev/null 2>/dev/null
rm -rf /compat/linux
mkdir -p /compat/linux/proc
mkdir -p /compat/linux/sys
mkdir -p /compat/linux/usr
ln -s /usr/home /compat/linux/usr/home

echo \"Installing $SYSBASEORIGIN...\"
pkg \${PKG_CFLAG} ${PKG_FLAG} install -U -y $SYSBASEORIGIN 2>&1 | tee /pkg-add.log
if [ \$? -ne 0 ] ; then
  cat /pkg-add.log
  echo "FAILED INSTALLING $SYSBASEORIGIN"
  exit 1
fi

while read pkgLine
do
  pkgOrigin=\"\`echo \$pkgLine | cut -d ' ' -f 1\`\"
  pkgName=\"\`echo \$pkgLine | cut -d ' ' -f 2\`\"
  if [ ! -e \"\${pkgName}\" ] ; then
     echo \"No such package: \${pkgName}\"
     echo \"No such package: \${pkgName}\" >>/removed-pkg-list
     continue
  fi

  echo \"Installing \$pkgOrigin...\"
  pkg \${PKG_CFLAG} ${PKG_FLAG} install -U -y \${pkgOrigin} 2>&1 | tee /pkg-add.log
  if [ \$? -ne 0 ] ; then
     echo \"Failed installing \${pkgOrigin}\"
     cat /pkg-add.log
     echo \"Failed installing \${pkgOrigin}\" >>/failed-pkg-list
     cat /pkg-add.log >>/failed-pkg-list
  fi
done < /install-pkg-list
rm /pkg-add.log

echo \"Extracting ports overlay...\"
/usr/local/bin/pc-extractoverlay ports
if [ \$? -ne 0 ] ; then exit 1; fi

echo \"Updating pkgng config...\"
/usr/local/bin/pc-updatemanager syncconf
if [ \$? -ne 0 ] ; then exit 1; fi

# Save the log files
if [ ! -d \"/usr/local/log/pc-updatemanager\" ] ; then
  mkdir -p /usr/local/log/pc-updatemanager
fi
touch /install-pkg-list
touch /removed-pkg-list
touch /failed-pkg-list
mv /install-pkg-list /usr/local/log/pc-updatemanager/
mv /removed-pkg-list /usr/local/log/pc-updatemanager/
mv /failed-pkg-list /usr/local/log/pc-updatemanager/

# Check for old PEFS on base system and switch to PKG version if possible
grep -q \"pam_pefs.so\" /etc/pam.d/system
if [ \$? -eq 0 ] ; then
  grep -q \"/usr/local/lib/pam_pefs.so\" /etc/pam.d/system
  if [ \$? -ne 0 -a -e \"/usr/local/lib/pam_pefs.so\" ] ; then
    sed -i '' 's|pam_pefs.so|/usr/local/lib/pam_pefs.so|g' /etc/pam.d/system
  fi
  grep -q \"/usr/local/lib/pam_pefs.so\" /etc/pam.d/other
  if [ \$? -ne 0 -a -e \"/usr/local/lib/pam_pefs.so\" ] ; then
    sed -i '' 's|pam_pefs.so|/usr/local/lib/pam_pefs.so|g' /etc/pam.d/other
  fi
fi

# If PEFS has been removed, get rid of PAM module
if [ ! -e \"/usr/local/lib/pam_pefs.so\" ] ; then
  sed -i '' '/pam_pefs.so/d' /etc/pam.d/other
  sed -i '' '/pam_pefs.so/d' /etc/pam.d/system
fi

exit 0
" > ${STAGEMNT}/.doPkgUp.sh

}

install_pkgs_chroot()
{
  # Run it now
  echo_log "Installing packages to stage BE... (This may take a while)"
  rc_halt_cleanup "chroot ${STAGEMNT} sh /.doPkgUp.sh" 2>&1 | tee -a ${LOGOUT}
  rm ${STAGEMNT}/.doPkgUp.sh
}

prep_freebsd_update_hack()
{
   FREEBSDUP="/.freebsd-up.sh"
   echo "#!/bin/sh
cat /usr/sbin/freebsd-update | sed 's|! -t 0|-z '1'|g' > /.fbsdup
chmod 755 /.fbsdup
/.fbsdup --non-interactive \$1 \$2 \$3 \$4 \$5
res=\$?
rm /.fbsdup
exit \$res
" >${STAGEMNT}${FREEBSDUP}
   chmod 755 ${STAGEMNT}${FREEBSDUP}
}

run_freebsd_update_script()
{
  prep_freebsd_update_hack

  # Start the upgrade with freebsd-update, get files downloaded installed
  echo_log "Fetching freebsd-update files..."
  rc_halt_cleanup "chroot ${STAGEMNT} ${FREEBSDUP} fetch" 2>&1 | tee -a ${LOGOUT}
  echo_log "Installing freebsd-update files..."
  rc_halt_cleanup "chroot ${STAGEMNT} ${FREEBSDUP} install" 2>&1 | tee -a ${LOGOUT}

  # Run again to remove any shared objs
  chroot ${STAGEMNT} ${FREEBSDUP} install >/dev/null 2>/dev/null
  NEWFREEBSDVERSION="`chroot ${STAGEMNT} /bin/freebsd-version`"

  rm ${STAGEMNT}/${FREEBSDUP}
}

prep_rc_script()
{
  prep_freebsd_update_hack

  # Start the upgrade with freebsd-update, get files downloaded and kernel installed
  rc_halt_cleanup "chroot ${STAGEMNT} ${FREEBSDUP} -r $NEWFREEBSDVERSION upgrade" 2>&1 | tee -a ${LOGOUT}
  rc_halt_cleanup "chroot ${STAGEMNT} ${FREEBSDUP} install" 2>&1 | tee -a ${LOGOUT}

  rm ${STAGEMNT}/${FREEBSDUP}

  # Now prep the RC script to do the rest of the upgrade after reboot
  rc_halt_cleanup "chroot ${STAGEMNT} mv /etc/rc /etc/rc-orig"
  rc_halt_cleanup "chroot ${STAGEMNT} mkdir -p /compat/linux/proc"
  rc_halt_cleanup "chroot ${STAGEMNT} mkdir -p /compat/linux/sys"
  rc_halt_cleanup "cp ${PROGDIR}/rc-update ${STAGEMNT}/etc/rc"
  rc_halt_cleanup "cp ${PROGDIR}/rc-update ${STAGEMNT}/etc/rc-update"
  rc_halt_cleanup "cp ${PROGDIR}/rc-doupdate ${STAGEMNT}/etc/rc-doupdate"
}

umount_stage_be()
{
  echo_log "Unmounting stage BE..."
  if [ ! -d "${STAGEMNT}/usr/local/log/pc-updatemanager" ] ; then
     mkdir -p "${STAGEMNT}/usr/local/log/pc-updatemanager"
  fi
  rc_halt_cleanup "cp ${PKGUPGRADELOG} ${STAGEMNT}/usr/local/log/pc-updatemanager/upgrade.log"

  # Figure out the name of the new BE
  nDate=`date "+%Y%m%d_%H%M%S"`
  if [ -n "$NEWFREEBSDVERSION" ] ; then
    newBEName="${NEWFREEBSDVERSION}-up-${nDate}"
  else
    beVer="`chroot ${STAGEMNT} /bin/freebsd-version`"
    if [ -z "$beVer" ] ; then
      beVer="`uname -r`"
    fi
    newBEName="${beVer}-up-${nDate}"
  fi

  # Now cleanup / unmount
  rc_halt "umount -f ${STAGEMNT}/dev"
  rc_halt "beadm umount -f ${STAGEBE}"
}

mk_stage_be_default()
{
  # Rename the BE
  rc_halt "beadm rename $STAGEBE $newBEName"
  # Rename the nickname
  rc_nohalt "beadm rename -n ${TMPNICK} ${newBEName}"
  rc_halt "beadm activate $newBEName"

  # Only update grub if its installed
  if [ -e "/boot/grub/grub.cfg" ] ; then
    rc_halt "grub-mkconfig -o /boot/grub/grub.cfg"
  fi
}

do_auto_be()
{
  # User requested a new autobe to be created
  create_auto_beadm
}

touch_updateinprogress()
{
   if [ -e "/tmp/.rebootRequired" ] ; then
      if [ "`cat /tmp/.rebootRequired`" = "`who -b`" ] ; then
        exit_err "Waiting to reboot from previous update!"
      fi
   fi
   if [ -e "/tmp/.updateInProgress" ] ; then
      pgrep -F /tmp/.updateInProgress >/dev/null 2>/dev/null
      if [ $? -eq 0 ] ; then
        exit_err "Another update is in progress!"
      fi
   fi
   echo "$$" > /tmp/.updateInProgress
}

touch_reboot()
{
   rm /tmp/.updateInProgress
   who -b >  /tmp/.rebootRequired
}

require_root()
{
  if [ `id -u` != "0" ] ; then exit_err "Must be run as root!" ; fi
}

rotate_log()
{
  if [ -e "$LOGOUT" ] ; then
     cp ${LOGOUT} ${LOGOUT}.prev
  fi
  if [ `id -u` = "0" ] ; then
    echo "pc-updatemanager: `date`" > $LOGOUT
  fi
}

run_update_pre()
{
  UPDATEDOTDPRE="${UPDATEDOTD}/pre"
  if [ ! -d "${UPDATEDOTDPRE}" ] ; then return 0; fi

  for pre in `ls ${UPDATEDOTDPRE}`
  do
    if [ "$pre" = "README" ] ; then continue ; fi

    echo "Running pre-update script: $pre"
    sh ${UPDATEDOTDPRE}/${pre} "$1"
    if [ $? -ne 0 ] ; then
       exit_err "Failed running pre-update script: $pre"
    fi
  done
}

run_update_post()
{
  UPDATEDOTDPOST="${UPDATEDOTD}/post"
  if [ ! -d "${UPDATEDOTDPOST}" ] ; then return 0; fi

  for post in `ls ${UPDATEDOTDPOST}`
  do
    if [ "$post" = "README" ] ; then continue ; fi

    echo "Running post-update script: $post"
    sh ${UPDATEDOTDPOST}/${post} "$1"
    if [ $? -ne 0 ] ; then
       echo "WARNING: Failed running post-update script: $post"
    fi
  done
}

if [ "`id -u`" = "0" ] ; then
  # Make the installed directory for this version
  if [ ! -d "${INSDIR}/${SYSVER}" ] ; then mkdir -p ${INSDIR}/${SYSVER} ; fi

  # Make the ignore directory for this version
  if [ ! -d "${IGNDIR}/${SYSVER}" ] ; then mkdir -p ${IGNDIR}/${SYSVER} ; fi
fi

if [ $# -eq 0 ] ; then
   show_usage
   exit 1
fi


while [ $# -gt 0 ] ; do

   case $1 in
	  autobe) require_root
		  do_auto_be ;;
	   check) do_fbsdcheck
		  get_update_file
                  do_check
		  exit $?
		  break
                  ;;
        showeol)  get_update_file
                  do_eol_display 
		  exit $?
		  break
		  ;;
        branches) require_root
		  get_update_file
                  list_branches ; break ;;
        chbranch) require_root
		  rotate_log
		  get_update_file
                  do_branch "${2}"
		  exit 0
                  break
                  ;;
	pkgcheck) checkup_pkgs
		  exit $?
                  break
                  ;;
	syncconf) require_root
		  sync_pkgconf ; break ;;
       confcheck) check_pkgconf ; break ;;
       pkgupdate) require_root
		  rotate_log
		  update_pkgs_only "$2"
		  exit 0
                  break
                  ;;
  fbsdupdatepkgs) require_root
		  rotate_log
		  update_freebsd "pkgs"
		  exit 0
                  break
                  ;;
      fbsdupdate) require_root
		  rotate_log
		  update_freebsd ""
		  exit 0
                  break
                  ;;
 	 install) require_root
		  rotate_log
		  get_update_file
                  do_install "${2}"
		  exit 0
                  break
                  ;;
            cron) require_root
                  waittime=$(jot -r 1 1 3600)
                  sleep $waittime
                  do_fbsdcheck
                  get_update_file
                  do_check
                  checkup_pkgs ; break ;;
	*) show_usage ;;
   esac
   shift
done

exit 0
